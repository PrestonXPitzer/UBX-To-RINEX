"""
This file is used to convert raw GNSS messages into a rinex file
"""

from pyubx2 import UBXReader, UBXMessage, UBX_PROTOCOL
import datetime as dt
import serial
from threading import Lock

class observation:
    def __init__(self, timestamp : dt.datetime, phase:float, range:float):
        self.timestamp = timestamp
        self.phase = phase
        self.range = range
    #overload the string method
    def __str__(self):
        return f"Timestamp: {self.timestamp}, Phase: {self.phase}, Range: {self.range}"


def process_ubx_message(msg) -> observation:
    """
    For an incoming UBX message, extract the 3 required fields for a RINEX file
    These fields are:
    Timestamp
    Phase
    Range
    """
    msg = msg[1] #this is the payload as a ubx message
    
    if msg.identity =="RXM-RAWX":
        #get the timestamp
        timestamp = dt.datetime.now() #TODO: fix this to get the actual timestamp from the sat
        #get the phase
        phase = msg.cpMes_01
        #get the range
        range = msg.prMes_01
        o = observation(timestamp, phase, range)
        print(o)
        return o
    else:
        return None

def main():
    """
    Continuously read from the serial port and process incoming UBX Messages
    as messages are read, convert them to observation objects
    these observation objects are then formatted and written to a RINEX file
    """
    ser = serial.Serial('/dev/ttyACM0', 9600)
    #configure the ubx reader
    try:
        layers = 1
        transaction = 0
        cfgData = [('CFG_MSGOUT_UBX_RXM_RAWX_USB',1)] #Enables CFG-MSGOUT-UBX_RXM_RAWX_USB
        msg2 = UBXMessage.config_set(layers,transaction,cfgData)
        serial_lock = Lock()
        #This prevents messages from overwriting eachother in the threading
        serial_lock.acquire()
        ser.write(msg2.serialize())
        serial_lock.release()
    except:
        pass
    reader = UBXReader(ser, protfilter=(UBX_PROTOCOL))
    observations = []
    while True:
        try:
            msg = reader.read()
            obs = process_ubx_message(msg)
            if obs != None:
                observations.append(obs)             
                print(f"Timestamp: {obs.timestamp}, Phase: {obs.phase}, Range: {obs.range}")
        except KeyboardInterrupt:
            break
    #Write the observations to a RINEX file
    #get the current time so we know how to format the filename
    now = dt.datetime.now()
    #get the last two digits of the year
    year = now.year % 100
    filename = f"{now.month}_{now.day}_{now.hour}.{year}o"
    with open(filename, "w") as f:
        #write the header
        f.write("3.03           OBSERVATION DATA    M (MIXED)     RINEX VERSION / TYPE\n")
        f.write("GENERATED BY ZED-F9P AND PYTHON SCRIPT  PPITZER               COMMENT\n")
        #OBSERVER/AGENCY LINE
        f.write("SPACEATVT                                           OBSERVER / AGENCY\n")
        # REC # / TYPE / VERS
        f.write("00000000                                RECEIVER NUMBER / TYPE / VERS\n")
        #ANT # / TYPE
        f.write("00000000                                        ANTENNA NUMBER / TYPE\n")
        #APPROX POSITION XYZ
        f.write("  0.0000  0.0000  0.0000                          APPROX POSITION XYZ\n") #TODO: get the actual position
        #ANTENNA: DELTA H/E/N
        f.write("  0.0000  0.0000  0.0000                         ANTENNA: DELTA H/E/N\n") #TODO: figure out wtf this is
        #Types of observerables
        f.write(f"L1    L2    L5                                   TYPES OF OBSERVATION\n")
        #first and last observations
        f.write(f"{observations[0].timestamp}                          TIME OF FIRST OBS\n")
        f.write(f"{observations[-1].timestamp}                           TIME OF LAST OBS\n")
        #interval
        f.write("1.0000                                                       INTERVAL\n")
        f.write("                                                        END OF HEADER\n")
        #epoch header
        f.write(f"{observations[0].timestamp.year} {observations[0].timestamp.month} {observations[0].timestamp.day} {observations[0].timestamp.hour} {observations[0].timestamp.minute} {observations[0].timestamp.second}  0.0000000  6    G  7G 8G 9G10G11G12G    C1C L1C L2C L5Q  C1W L1W L2W L5I  C1P L1P L2P L5X\n")
        #write the observations
        for obs in observations:
            f.write(f"{obs.timestamp.isoformat()}    {obs.phase}    {obs.range}\n")

if __name__ == "__main__":
    main()
        